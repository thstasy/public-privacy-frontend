{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute } from 'three';\nimport { merge, extent, mean } from 'd3-array';\nimport earcut from 'earcut';\nimport Delaunator from 'delaunator';\nimport turfPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { geoBounds, geoContains, geoDistance, geoInterpolate } from 'd3-geo';\nimport { geoVoronoi } from 'd3-geo-voronoi';\nimport { scaleLinear } from 'd3-scale';\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction geoPolygonTriangulate(polygon) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === void 0 ? Infinity : _ref$resolution;\n  var contour = interpolateContourPoints(polygon, resolution);\n  var edgePoints = merge(contour);\n  var innerPoints = getInnerGeoPoints(polygon, resolution);\n  var points = [].concat(_toConsumableArray(edgePoints), _toConsumableArray(innerPoints));\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n  var _geoBounds = geoBounds(boundariesGeojson),\n    _geoBounds2 = _slicedToArray(_geoBounds, 2),\n    _geoBounds2$ = _slicedToArray(_geoBounds2[0], 2),\n    minLng = _geoBounds2$[0],\n    minLat = _geoBounds2$[1],\n    _geoBounds2$2 = _slicedToArray(_geoBounds2[1], 2),\n    maxLng = _geoBounds2$2[0],\n    maxLat = _geoBounds2$2[1];\n  var crossesPoleOrAntimeridian = minLng > maxLng // crosses antimeridian\n  || maxLat >= 89 // crosses north pole\n  || minLat <= -89; // crosses south pole\n\n  var indices = [];\n  if (crossesPoleOrAntimeridian) {\n    // Use d3-geo-voronoi. Slowest, but most accurate for polygons that cross poles or anti-meridian\n    var vt = geoVoronoi(points).triangles(); // geoDelaunay generates more triangles than needed\n    var pntMap = new Map(points.map(function (_ref2, idx) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n        lng = _ref3[0],\n        lat = _ref3[1];\n      return [\"\".concat(lng, \"-\").concat(lat), idx];\n    }));\n    vt.features.forEach(function (f) {\n      var _indices;\n      var triangle = f.geometry.coordinates[0].slice(0, 3).reverse(); // reverse wound to match earcut\n\n      var inds = [];\n      triangle.forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n          lng = _ref5[0],\n          lat = _ref5[1];\n        var k = \"\".concat(lng, \"-\").concat(lat);\n        pntMap.has(k) && inds.push(pntMap.get(k));\n      });\n      if (inds.length !== 3) return; // triangle malfunction\n\n      // exclude edge triangles outside polygon perimeter or through holes\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = f.properties.circumcenter;\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;\n      }\n      (_indices = indices).push.apply(_indices, inds);\n    });\n  } else if (!innerPoints.length) {\n    // earcut triangulation slightly more performing if it's only using the polygon perimeter\n    var _earcut$flatten = earcut.flatten(contour),\n      vertices = _earcut$flatten.vertices,\n      _earcut$flatten$holes = _earcut$flatten.holes,\n      holes = _earcut$flatten$holes === void 0 ? [] : _earcut$flatten$holes;\n    indices = earcut(vertices, holes, 2);\n  } else {\n    // use delaunator\n    var delaunay = Delaunator.from(points);\n    var _loop = function _loop(i) {\n      var _indices2;\n      var inds = [2, 1, 0].map(function (idx) {\n        return delaunay.triangles[i + idx];\n      }); // reverse wound to have same orientation as earcut\n      var triangle = inds.map(function (indice) {\n        return points[indice];\n      });\n\n      // exclude edge triangles outside polygon perimeter or through holes\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = [0, 1].map(function (coordIdx) {\n          return mean(triangle, function (p) {\n            return p[coordIdx];\n          });\n        });\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return \"continue\";\n      }\n      (_indices2 = indices).push.apply(_indices2, _toConsumableArray(inds));\n    };\n    for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {\n      var _ret = _loop(i);\n      if (_ret === \"continue\") continue;\n    }\n  }\n\n  // calc uvs\n  var lngUvScale = scaleLinear(extent(points, function (d) {\n    return d[0];\n  }), [0, 1]);\n  var latUvScale = scaleLinear(extent(points, function (d) {\n    return d[1];\n  }), [0, 1]);\n  var uvs = points.map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n      lng = _ref7[0],\n      lat = _ref7[1];\n    return [lngUvScale(lng), latUvScale(lat)];\n  });\n  var triangles = {\n    points: points,\n    indices: indices,\n    uvs: uvs\n  };\n  return {\n    contour: contour,\n    triangles: triangles\n  };\n}\nfunction interpolateContourPoints(polygon, maxDistance) {\n  // add interpolated points for segments that are further apart than the max distance\n  return polygon.map(function (coords) {\n    var pnts = [];\n    var prevPnt;\n    coords.forEach(function (pnt) {\n      if (prevPnt) {\n        var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;\n        if (dist > maxDistance) {\n          var interpol = geoInterpolate(prevPnt, pnt);\n          var tStep = 1 / Math.ceil(dist / maxDistance);\n          var t = tStep;\n          while (t < 1) {\n            pnts.push(interpol(t));\n            t += tStep;\n          }\n        }\n      }\n      pnts.push(prevPnt = pnt);\n    });\n    return pnts;\n  });\n}\nfunction getInnerGeoPoints(polygon, maxDistance) {\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n  var _geoBounds3 = geoBounds(boundariesGeojson),\n    _geoBounds4 = _slicedToArray(_geoBounds3, 2),\n    _geoBounds4$ = _slicedToArray(_geoBounds4[0], 2),\n    minLng = _geoBounds4$[0],\n    minLat = _geoBounds4$[1],\n    _geoBounds4$2 = _slicedToArray(_geoBounds4[1], 2),\n    maxLng = _geoBounds4$2[0],\n    maxLat = _geoBounds4$2[1];\n\n  // polygon smaller than maxDistance -> no inner points\n  if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];\n  var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;\n  return getGeoSpiralGrid(maxDistance, {\n    minLng: minLng,\n    maxLng: maxLng,\n    minLat: minLat,\n    maxLat: maxLat\n  }).filter(function (pnt) {\n    return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);\n  });\n}\nfunction getGeoSpiralGrid(distanceBetweenPoints) {\n  var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    minLng = _ref8.minLng,\n    maxLng = _ref8.maxLng,\n    minLat = _ref8.minLat,\n    maxLat = _ref8.maxLat;\n  var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI);\n\n  // https://observablehq.com/@mbostock/spherical-fibonacci-lattice\n  var phi = (1 + Math.sqrt(5)) / 2; // golden ratio\n\n  var getPntLng = function getPntLng(idx) {\n    return idx / phi * 360 % 360 - 180;\n  };\n  var getPntLat = function getPntLat(idx) {\n    return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;\n  };\n  var getPntIdx = function getPntIdx(lat) {\n    return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;\n  };\n  var pntIdxRange = [maxLat !== undefined ? Math.ceil(getPntIdx(maxLat)) : 0, minLat !== undefined ? Math.floor(getPntIdx(minLat)) : numPoints - 1];\n  var isLngInRange = minLng === undefined && maxLng === undefined ? function () {\n    return true;\n  } : minLng === undefined ? function (lng) {\n    return lng <= maxLng;\n  } : maxLng === undefined ? function (lng) {\n    return lng >= minLng;\n  } : maxLng >= minLng ? function (lng) {\n    return lng >= minLng && lng <= maxLng;\n  } : function (lng) {\n    return lng >= minLng || lng <= maxLng;\n  }; // for ranges that cross the anti-meridian\n\n  var pnts = [];\n  for (var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++) {\n    var lng = getPntLng(i);\n    isLngInRange(lng) && pnts.push([lng, getPntLat(i)]);\n  }\n  return pnts;\n}\nfunction pointInside(pnt, polygon) {\n  var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // turf method is more performing but malfunctions if polygon includes a pole (lat = 90 | -90) or crosses the antimeridian (lng = 180 | -180)\n  return crossesPoleOrAntimeridian ? geoContains(polygon, pnt) : turfPointInPolygon(pnt, polygon);\n}\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute\n};\n\n// support both modes for backwards threejs compatibility\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nvar ConicPolygonBufferGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  _inherits(ConicPolygonBufferGeometry, _THREE$BufferGeometry);\n  var _super = _createSuper(ConicPolygonBufferGeometry);\n  function ConicPolygonBufferGeometry(polygonGeoJson, startHeight, endHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n    var _this;\n    _classCallCheck(this, ConicPolygonBufferGeometry);\n    _this = _super.call(this);\n    _this.type = 'ConicPolygonBufferGeometry';\n    _this.parameters = {\n      polygonGeoJson: polygonGeoJson,\n      startHeight: startHeight,\n      endHeight: endHeight,\n      closedBottom: closedBottom,\n      closedTop: closedTop,\n      includeSides: includeSides,\n      curvatureResolution: curvatureResolution\n    };\n\n    // defaults\n    startHeight = startHeight || 0;\n    endHeight = endHeight || 1;\n    closedBottom = closedBottom !== undefined ? closedBottom : true;\n    closedTop = closedTop !== undefined ? closedTop : true;\n    includeSides = includeSides !== undefined ? includeSides : true;\n    curvatureResolution = curvatureResolution || 5; // in angular degrees\n\n    // pre-calculate contour, triangulation and UV maps\n    var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {\n        resolution: curvatureResolution\n      }),\n      contour = _geoPolygonTriangulat.contour,\n      triangles = _geoPolygonTriangulat.triangles;\n    var flatUvs = merge(triangles.uvs);\n    var vertices = [];\n    var uvs = [];\n    var indices = [];\n    var groupCnt = 0; // add groups to apply different materials to torso / caps\n\n    var addGroup = function addGroup(groupData) {\n      var prevVertCnt = Math.round(vertices.length / 3);\n      var prevIndCnt = indices.length;\n      vertices = vertices.concat(groupData.vertices);\n      uvs = uvs.concat(groupData.uvs);\n      indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {\n        return ind + prevVertCnt;\n      }));\n      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n    };\n    includeSides && addGroup(generateTorso());\n    closedBottom && addGroup(generateCap(startHeight, false));\n    closedTop && addGroup(generateCap(endHeight, true));\n\n    // build geometry\n    _this.setIndex(indices);\n    _this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3));\n    _this[setAttributeFn]('uv', new THREE.Float32BufferAttribute(uvs, 2));\n\n    // auto-calculate normals\n    _this.computeVertexNormals();\n\n    //\n\n    function generateVertices(polygon, altitude) {\n      var coords3d = polygon.map(function (coords) {\n        return coords.map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            lng = _ref2[0],\n            lat = _ref2[1];\n          return polar2Cartesian(lat, lng, altitude);\n        });\n      });\n      // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n      return earcut.flatten(coords3d);\n    }\n    function generateTorso() {\n      var _generateVertices = generateVertices(contour, startHeight),\n        bottomVerts = _generateVertices.vertices,\n        holes = _generateVertices.holes;\n      var _generateVertices2 = generateVertices(contour, endHeight),\n        topVerts = _generateVertices2.vertices;\n      var vertices = merge([topVerts, bottomVerts]);\n      var numPoints = Math.round(topVerts.length / 3);\n      var holesIdx = new Set(holes);\n      var lastHoleIdx = 0;\n      var indices = [];\n      for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {\n        var v1Idx = v0Idx + 1; // next point\n        if (v1Idx === numPoints) {\n          v1Idx = lastHoleIdx; // close final loop\n        } else if (holesIdx.has(v1Idx)) {\n          var holeIdx = v1Idx;\n          v1Idx = lastHoleIdx; // close hole loop\n          lastHoleIdx = holeIdx;\n        }\n\n        // Each pair of coords generates two triangles (faces)\n        indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n        indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n      }\n      var uvs = []; // wrap texture around perimeter (u), with v=1 on top\n      for (var v = 1; v >= 0; v--) for (var i = 0; i < numPoints; i += 1) uvs.push(i / (numPoints - 1), v);\n      return {\n        indices: indices,\n        vertices: vertices,\n        uvs: uvs\n      };\n    }\n    function generateCap(radius) {\n      var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return {\n        // need to reverse-wind the bottom triangles to make them face outwards\n        indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),\n        vertices: generateVertices([triangles.points], radius).vertices,\n        uvs: flatUvs\n      };\n    }\n    return _this;\n  }\n  return _createClass(ConicPolygonBufferGeometry);\n}(THREE.BufferGeometry); //\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta),\n  // x\n  r * Math.cos(phi),\n  // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\nexport { ConicPolygonBufferGeometry, ConicPolygonBufferGeometry as ConicPolygonGeometry };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}