{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Float32BufferAttribute, InstancedBufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, Vector3 } from 'three';\nfunction computeMikkTSpaceTangents(geometry, MikkTSpace) {\n  var negateSign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!MikkTSpace || !MikkTSpace.isReady) {\n    throw new Error('BufferGeometryUtils: Initialized MikkTSpace library required.');\n  }\n  if (!geometry.hasAttribute('position') || !geometry.hasAttribute('normal') || !geometry.hasAttribute('uv')) {\n    throw new Error('BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.');\n  }\n  function getAttributeArray(attribute) {\n    if (attribute.normalized || attribute.isInterleavedBufferAttribute) {\n      var dstArray = new Float32Array(attribute.count * attribute.itemSize);\n      for (var i = 0, j = 0; i < attribute.count; i++) {\n        dstArray[j++] = attribute.getX(i);\n        dstArray[j++] = attribute.getY(i);\n        if (attribute.itemSize > 2) {\n          dstArray[j++] = attribute.getZ(i);\n        }\n      }\n      return dstArray;\n    }\n    if (attribute.array instanceof Float32Array) {\n      return attribute.array;\n    }\n    return new Float32Array(attribute.array);\n  }\n\n  // MikkTSpace algorithm requires non-indexed input.\n\n  var _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n  // Compute vertex tangents.\n\n  var tangents = MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position), getAttributeArray(_geometry.attributes.normal), getAttributeArray(_geometry.attributes.uv));\n\n  // Texture coordinate convention of glTF differs from the apparent\n  // default of the MikkTSpace library; .w component must be flipped.\n\n  if (negateSign) {\n    for (var i = 3; i < tangents.length; i += 4) {\n      tangents[i] *= -1;\n    }\n  }\n\n  //\n\n  _geometry.setAttribute('tangent', new BufferAttribute(tangents, 4));\n  if (geometry !== _geometry) {\n    geometry.copy(_geometry);\n  }\n  return geometry;\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries(geometries) {\n  var useGroups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isIndexed = geometries[0].index !== null;\n  var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  var attributes = {};\n  var morphAttributes = {};\n  var morphTargetsRelative = geometries[0].morphTargetsRelative;\n  var mergedGeometry = new BufferGeometry();\n  var offset = 0;\n  for (var i = 0; i < geometries.length; ++i) {\n    var geometry = geometries[i];\n    var attributesCount = 0;\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geometry.index !== null)) {\n      console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n      return null;\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (var name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n      if (attributes[name] === undefined) attributes[name] = [];\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n      return null;\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n      console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n      return null;\n    }\n    for (var _name in geometry.morphAttributes) {\n      if (!morphAttributesUsed.has(_name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n        return null;\n      }\n      if (morphAttributes[_name] === undefined) morphAttributes[_name] = [];\n      morphAttributes[_name].push(geometry.morphAttributes[_name]);\n    }\n    if (useGroups) {\n      var count = void 0;\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }\n\n  // merge indices\n\n  if (isIndexed) {\n    var indexOffset = 0;\n    var mergedIndex = [];\n    for (var _i = 0; _i < geometries.length; ++_i) {\n      var index = geometries[_i].index;\n      for (var j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geometries[_i].attributes.position.count;\n    }\n    mergedGeometry.setIndex(mergedIndex);\n  }\n\n  // merge attributes\n\n  for (var _name2 in attributes) {\n    var mergedAttribute = mergeAttributes(attributes[_name2]);\n    if (!mergedAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + _name2 + ' attribute.');\n      return null;\n    }\n    mergedGeometry.setAttribute(_name2, mergedAttribute);\n  }\n\n  // merge morph attributes\n\n  for (var _name3 in morphAttributes) {\n    var numMorphTargets = morphAttributes[_name3][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[_name3] = [];\n    for (var _i2 = 0; _i2 < numMorphTargets; ++_i2) {\n      var morphAttributesToMerge = [];\n      for (var _j = 0; _j < morphAttributes[_name3].length; ++_j) {\n        morphAttributesToMerge.push(morphAttributes[_name3][_j][_i2]);\n      }\n      var mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + _name3 + ' morphAttribute.');\n        return null;\n      }\n      mergedGeometry.morphAttributes[_name3].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes(attributes) {\n  var TypedArray;\n  var itemSize;\n  var normalized;\n  var gpuType = -1;\n  var arrayLength = 0;\n  for (var i = 0; i < attributes.length; ++i) {\n    var attribute = attributes[i];\n    if (attribute.isInterleavedBufferAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.');\n      return null;\n    }\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n      return null;\n    }\n    if (itemSize === undefined) itemSize = attribute.itemSize;\n    if (itemSize !== attribute.itemSize) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n      return null;\n    }\n    if (normalized === undefined) normalized = attribute.normalized;\n    if (normalized !== attribute.normalized) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n      return null;\n    }\n    if (gpuType === -1) gpuType = attribute.gpuType;\n    if (gpuType !== attribute.gpuType) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.');\n      return null;\n    }\n    arrayLength += attribute.array.length;\n  }\n  var array = new TypedArray(arrayLength);\n  var offset = 0;\n  for (var _i3 = 0; _i3 < attributes.length; ++_i3) {\n    array.set(attributes[_i3].array, offset);\n    offset += attributes[_i3].array.length;\n  }\n  var result = new BufferAttribute(array, itemSize, normalized);\n  if (gpuType !== undefined) {\n    result.gpuType = gpuType;\n  }\n  return result;\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute(attribute) {\n  if (attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute) {\n    return deinterleaveAttribute(attribute);\n  }\n  if (attribute.isInstancedBufferAttribute) {\n    return new InstancedBufferAttribute().copy(attribute);\n  }\n  return new BufferAttribute().copy(attribute);\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes(attributes) {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  var TypedArray;\n  var arrayLength = 0;\n  var stride = 0;\n\n  // calculate the length and type of the interleavedBuffer\n  for (var i = 0, l = attributes.length; i < l; ++i) {\n    var attribute = attributes[i];\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved');\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n\n  // Create the set of buffer attributes\n  var interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  var offset = 0;\n  var res = [];\n  var getters = ['getX', 'getY', 'getZ', 'getW'];\n  var setters = ['setX', 'setY', 'setZ', 'setW'];\n  for (var j = 0, _l = attributes.length; j < _l; j++) {\n    var _attribute = attributes[j];\n    var itemSize = _attribute.itemSize;\n    var count = _attribute.count;\n    var iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, _attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (var c = 0; c < count; c++) {\n      for (var k = 0; k < itemSize; k++) {\n        iba[setters[k]](c, _attribute[getters[k]](c));\n      }\n    }\n  }\n  return res;\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute(attribute) {\n  var cons = attribute.data.array.constructor;\n  var count = attribute.count;\n  var itemSize = attribute.itemSize;\n  var normalized = attribute.normalized;\n  var array = new cons(count * itemSize);\n  var newAttribute;\n  if (attribute.isInstancedInterleavedBufferAttribute) {\n    newAttribute = new InstancedBufferAttribute(array, itemSize, normalized, attribute.meshPerAttribute);\n  } else {\n    newAttribute = new BufferAttribute(array, itemSize, normalized);\n  }\n  for (var i = 0; i < count; i++) {\n    newAttribute.setX(i, attribute.getX(i));\n    if (itemSize >= 2) {\n      newAttribute.setY(i, attribute.getY(i));\n    }\n    if (itemSize >= 3) {\n      newAttribute.setZ(i, attribute.getZ(i));\n    }\n    if (itemSize >= 4) {\n      newAttribute.setW(i, attribute.getW(i));\n    }\n  }\n  return newAttribute;\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry(geometry) {\n  var attributes = geometry.attributes;\n  var morphTargets = geometry.morphTargets;\n  var attrMap = new Map();\n  for (var key in attributes) {\n    var attr = attributes[key];\n    if (attr.isInterleavedBufferAttribute) {\n      if (!attrMap.has(attr)) {\n        attrMap.set(attr, deinterleaveAttribute(attr));\n      }\n      attributes[key] = attrMap.get(attr);\n    }\n  }\n  for (var _key in morphTargets) {\n    var _attr = morphTargets[_key];\n    if (_attr.isInterleavedBufferAttribute) {\n      if (!attrMap.has(_attr)) {\n        attrMap.set(_attr, deinterleaveAttribute(_attr));\n      }\n      morphTargets[_key] = attrMap.get(_attr);\n    }\n  }\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed(geometry) {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  var mem = 0;\n  for (var name in geometry.attributes) {\n    var attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  var indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices(geometry) {\n  var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n  tolerance = Math.max(tolerance, Number.EPSILON);\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  var hashToIndex = {};\n  var indices = geometry.getIndex();\n  var positions = geometry.getAttribute('position');\n  var vertexCount = indices ? indices.count : positions.count;\n\n  // next value for triangle indices\n  var nextIndex = 0;\n\n  // attributes and new attribute arrays\n  var attributeNames = Object.keys(geometry.attributes);\n  var tmpAttributes = {};\n  var tmpMorphAttributes = {};\n  var newIndices = [];\n  var getters = ['getX', 'getY', 'getZ', 'getW'];\n  var setters = ['setX', 'setY', 'setZ', 'setW'];\n\n  // Initialize the arrays, allocating space conservatively. Extra\n  // space will be trimmed in the last step.\n  for (var i = 0, l = attributeNames.length; i < l; i++) {\n    var name = attributeNames[i];\n    var attr = geometry.attributes[name];\n    tmpAttributes[name] = new BufferAttribute(new attr.array.constructor(attr.count * attr.itemSize), attr.itemSize, attr.normalized);\n    var morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      tmpMorphAttributes[name] = new BufferAttribute(new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize), morphAttr.itemSize, morphAttr.normalized);\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  var decimalShift = Math.log10(1 / tolerance);\n  var shiftMultiplier = Math.pow(10, decimalShift);\n  for (var _i4 = 0; _i4 < vertexCount; _i4++) {\n    var index = indices ? indices.getX(_i4) : _i4;\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    var hash = '';\n    for (var j = 0, _l2 = attributeNames.length; j < _l2; j++) {\n      var _name4 = attributeNames[j];\n      var attribute = geometry.getAttribute(_name4);\n      var itemSize = attribute.itemSize;\n      for (var k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        hash += \"\".concat(~~(attribute[getters[k]](index) * shiftMultiplier), \",\");\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      // copy data to the new index in the temporary attributes\n      for (var _j2 = 0, _l3 = attributeNames.length; _j2 < _l3; _j2++) {\n        var _name5 = attributeNames[_j2];\n        var _attribute2 = geometry.getAttribute(_name5);\n        var _morphAttr = geometry.morphAttributes[_name5];\n        var _itemSize = _attribute2.itemSize;\n        var newarray = tmpAttributes[_name5];\n        var newMorphArrays = tmpMorphAttributes[_name5];\n        for (var _k = 0; _k < _itemSize; _k++) {\n          var getterFunc = getters[_k];\n          var setterFunc = setters[_k];\n          newarray[setterFunc](nextIndex, _attribute2[getterFunc](index));\n          if (_morphAttr) {\n            for (var m = 0, ml = _morphAttr.length; m < ml; m++) {\n              newMorphArrays[m][setterFunc](nextIndex, _morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n\n  // generate result BufferGeometry\n  var result = geometry.clone();\n  for (var _name6 in geometry.attributes) {\n    var tmpAttribute = tmpAttributes[_name6];\n    result.setAttribute(_name6, new BufferAttribute(tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize), tmpAttribute.itemSize, tmpAttribute.normalized));\n    if (!(_name6 in tmpMorphAttributes)) continue;\n    for (var _j3 = 0; _j3 < tmpMorphAttributes[_name6].length; _j3++) {\n      var tmpMorphAttribute = tmpMorphAttributes[_name6][_j3];\n      result.morphAttributes[_name6][_j3] = new BufferAttribute(tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize), tmpMorphAttribute.itemSize, tmpMorphAttribute.normalized);\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices);\n  return result;\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    var index = geometry.getIndex();\n\n    // generate index if not present\n\n    if (index === null) {\n      var indices = [];\n      var position = geometry.getAttribute('position');\n      if (position !== undefined) {\n        for (var i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    }\n\n    //\n\n    var numberOfTriangles = index.count - 2;\n    var newIndices = [];\n    if (drawMode === TriangleFanDrawMode) {\n      // gl.TRIANGLE_FAN\n\n      for (var _i5 = 1; _i5 <= numberOfTriangles; _i5++) {\n        newIndices.push(index.getX(0));\n        newIndices.push(index.getX(_i5));\n        newIndices.push(index.getX(_i5 + 1));\n      }\n    } else {\n      // gl.TRIANGLE_STRIP\n\n      for (var _i6 = 0; _i6 < numberOfTriangles; _i6++) {\n        if (_i6 % 2 === 0) {\n          newIndices.push(index.getX(_i6));\n          newIndices.push(index.getX(_i6 + 1));\n          newIndices.push(index.getX(_i6 + 2));\n        } else {\n          newIndices.push(index.getX(_i6 + 2));\n          newIndices.push(index.getX(_i6 + 1));\n          newIndices.push(index.getX(_i6));\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    }\n\n    // build final geometry\n\n    var newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n    return geometry;\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes(object) {\n  var _vA = new Vector3();\n  var _vB = new Vector3();\n  var _vC = new Vector3();\n  var _tempA = new Vector3();\n  var _tempB = new Vector3();\n  var _tempC = new Vector3();\n  var _morphA = new Vector3();\n  var _morphB = new Vector3();\n  var _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a);\n    _vB.fromBufferAttribute(attribute, b);\n    _vC.fromBufferAttribute(attribute, c);\n    var morphInfluences = object.morphTargetInfluences;\n    if (morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (var _i7 = 0, _il = morphAttribute.length; _i7 < _il; _i7++) {\n        var influence = morphInfluences[_i7];\n        var morph = morphAttribute[_i7];\n        if (influence === 0) continue;\n        _tempA.fromBufferAttribute(morph, a);\n        _tempB.fromBufferAttribute(morph, b);\n        _tempC.fromBufferAttribute(morph, c);\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object.isSkinnedMesh) {\n      object.applyBoneTransform(a, _vA);\n      object.applyBoneTransform(b, _vB);\n      object.applyBoneTransform(c, _vC);\n    }\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\n  }\n  var geometry = object.geometry;\n  var material = object.material;\n  var a, b, c;\n  var index = geometry.index;\n  var positionAttribute = geometry.attributes.position;\n  var morphPosition = geometry.morphAttributes.position;\n  var morphTargetsRelative = geometry.morphTargetsRelative;\n  var normalAttribute = geometry.attributes.normal;\n  var morphNormal = geometry.morphAttributes.position;\n  var groups = geometry.groups;\n  var drawRange = geometry.drawRange;\n  var i, j, il, jl;\n  var group;\n  var start, end;\n  var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n          _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n        _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n  var morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  var morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute\n  };\n}\nfunction mergeGroups(geometry) {\n  if (geometry.groups.length === 0) {\n    console.warn('THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.');\n    return geometry;\n  }\n  var groups = geometry.groups;\n\n  // sort groups by material index\n\n  groups = groups.sort(function (a, b) {\n    if (a.materialIndex !== b.materialIndex) return a.materialIndex - b.materialIndex;\n    return a.start - b.start;\n  });\n\n  // create index for non-indexed geometries\n\n  if (geometry.getIndex() === null) {\n    var positionAttribute = geometry.getAttribute('position');\n    var indices = [];\n    for (var i = 0; i < positionAttribute.count; i += 3) {\n      indices.push(i, i + 1, i + 2);\n    }\n    geometry.setIndex(indices);\n  }\n\n  // sort index\n\n  var index = geometry.getIndex();\n  var newIndices = [];\n  for (var _i8 = 0; _i8 < groups.length; _i8++) {\n    var group = groups[_i8];\n    var groupStart = group.start;\n    var groupLength = groupStart + group.count;\n    for (var j = groupStart; j < groupLength; j++) {\n      newIndices.push(index.getX(j));\n    }\n  }\n  geometry.dispose(); // Required to force buffer recreation\n  geometry.setIndex(newIndices);\n\n  // update groups indices\n\n  var start = 0;\n  for (var _i9 = 0; _i9 < groups.length; _i9++) {\n    var _group = groups[_i9];\n    _group.start = start;\n    start += _group.count;\n  }\n\n  // merge groups\n\n  var currentGroup = groups[0];\n  geometry.groups = [currentGroup];\n  for (var _i10 = 1; _i10 < groups.length; _i10++) {\n    var _group2 = groups[_i10];\n    if (currentGroup.materialIndex === _group2.materialIndex) {\n      currentGroup.count += _group2.count;\n    } else {\n      currentGroup = _group2;\n      geometry.groups.push(currentGroup);\n    }\n  }\n  return geometry;\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals(geometry) {\n  var creaseAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.PI / 3;\n  var creaseDot = Math.cos(creaseAngle);\n  var hashMultiplier = (1 + 1e-10) * 1e2;\n\n  // reusable vectors\n  var verts = [new Vector3(), new Vector3(), new Vector3()];\n  var tempVec1 = new Vector3();\n  var tempVec2 = new Vector3();\n  var tempNorm = new Vector3();\n  var tempNorm2 = new Vector3();\n\n  // hashes a vector\n  function hashVertex(v) {\n    var x = ~~(v.x * hashMultiplier);\n    var y = ~~(v.y * hashMultiplier);\n    var z = ~~(v.z * hashMultiplier);\n    return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n  }\n\n  // BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n  // and returns the original geometry\n  var resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  var posAttr = resultGeometry.attributes.position;\n  var vertexMap = {};\n\n  // find all the normals shared by commonly located vertices\n  for (var i = 0, l = posAttr.count / 3; i < l; i++) {\n    var i3 = 3 * i;\n    var a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    var b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    var c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n\n    // add the normal to the map for all vertices\n    var normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (var n = 0; n < 3; n++) {\n      var vert = verts[n];\n      var hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n\n  // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n  var normalArray = new Float32Array(posAttr.count * 3);\n  var normAttr = new BufferAttribute(normalArray, 3, false);\n  for (var _i11 = 0, _l4 = posAttr.count / 3; _i11 < _l4; _i11++) {\n    // get the face normal for this vertex\n    var _i12 = 3 * _i11;\n    var _a = verts[0].fromBufferAttribute(posAttr, _i12 + 0);\n    var _b = verts[1].fromBufferAttribute(posAttr, _i12 + 1);\n    var _c = verts[2].fromBufferAttribute(posAttr, _i12 + 2);\n    tempVec1.subVectors(_c, _b);\n    tempVec2.subVectors(_a, _b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n\n    // average all normals that meet the threshold and set the normal value\n    for (var _n = 0; _n < 3; _n++) {\n      var _vert = verts[_n];\n      var _hash = hashVertex(_vert);\n      var otherNormals = vertexMap[_hash];\n      tempNorm2.set(0, 0, 0);\n      for (var k = 0, lk = otherNormals.length; k < lk; k++) {\n        var otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(_i12 + _n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute('normal', normAttr);\n  return resultGeometry;\n}\nfunction mergeBufferGeometries(geometries) {\n  var useGroups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  console.warn('THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().'); // @deprecated, r151\n  return mergeGeometries(geometries, useGroups);\n}\nfunction mergeBufferAttributes(attributes) {\n  console.warn('THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes().'); // @deprecated, r151\n  return mergeAttributes(attributes);\n}\nexport { computeMikkTSpaceTangents, mergeGeometries, mergeBufferGeometries, mergeAttributes, mergeBufferAttributes, interleaveAttributes, estimateBytesUsed, mergeVertices, toTrianglesDrawMode, computeMorphedAttributes, mergeGroups, toCreasedNormals };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}