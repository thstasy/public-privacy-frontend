{"ast":null,"code":"import _toConsumableArray from \"/Users/stasy/Desktop/Public+Privacy_0831/public-privacy-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/stasy/Desktop/Public+Privacy_0831/public-privacy-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/stasy/Desktop/Public+Privacy_0831/public-privacy-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Delaunay } from \"d3-delaunay\";\nimport { scaleLinear } from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\nexport default function () {\n  var _marked = /*#__PURE__*/_regeneratorRuntime().mark(tricontours),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(isobands);\n  // accessors\n  var x = function x(d) {\n      return d[0];\n    },\n    y = function y(d) {\n      return d[1];\n    },\n    value = function value(d) {\n      return isFinite(+d[2]) ? +d[2] : 0;\n    },\n    triangulate = Delaunay.from,\n    pointInterpolate = function pointInterpolate(i, j, a) {\n      var _triangulation = triangulation,\n        points = _triangulation.points;\n      var A = [points[2 * i], points[2 * i + 1]],\n        B = [points[2 * j], points[2 * j + 1]];\n      return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n    },\n    ringsort = planarRingsort;\n  var thresholds, values, triangulation;\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear().domain(extent(values)).nice().ticks(thresholds);\n    }\n  }\n  function tricontours(points) {\n    var _iterator, _step, threshold, polygon;\n    return _regeneratorRuntime().wrap(function tricontours$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          init(points);\n          _iterator = _createForOfIteratorHelper(thresholds);\n          _context.prev = 2;\n          _iterator.s();\n        case 4:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 11;\n            break;\n          }\n          threshold = _step.value;\n          polygon = tricontour(triangulation, values, threshold);\n          _context.next = 9;\n          return {\n            type: \"MultiPolygon\",\n            coordinates: polygon,\n            value: threshold\n          };\n        case 9:\n          _context.next = 4;\n          break;\n        case 11:\n          _context.next = 16;\n          break;\n        case 13:\n          _context.prev = 13;\n          _context.t0 = _context[\"catch\"](2);\n          _iterator.e(_context.t0);\n        case 16:\n          _context.prev = 16;\n          _iterator.f();\n          return _context.finish(16);\n        case 19:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _marked, null, [[2, 13, 16, 19]]);\n  }\n  function contour(points, threshold) {\n    init(points);\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n  function isobands(points) {\n    var p0, p1, th0, _iterator2, _step2, th;\n    return _regeneratorRuntime().wrap(function isobands$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          init(points);\n          _iterator2 = _createForOfIteratorHelper(thresholds);\n          _context2.prev = 2;\n          _iterator2.s();\n        case 4:\n          if ((_step2 = _iterator2.n()).done) {\n            _context2.next = 14;\n            break;\n          }\n          th = _step2.value;\n          if (p1) p0 = p1;\n          p1 = merge(tricontour(triangulation, values, th));\n          if (!p0) {\n            _context2.next = 11;\n            break;\n          }\n          _context2.next = 11;\n          return {\n            type: \"MultiPolygon\",\n            coordinates: ringsort(p0.concat(p1.map(function (ring) {\n              return ring.slice().reverse();\n            }))),\n            value: th0,\n            valueMax: th\n          };\n        case 11:\n          th0 = th;\n        case 12:\n          _context2.next = 4;\n          break;\n        case 14:\n          _context2.next = 19;\n          break;\n        case 16:\n          _context2.prev = 16;\n          _context2.t0 = _context2[\"catch\"](2);\n          _iterator2.e(_context2.t0);\n        case 19:\n          _context2.prev = 19;\n          _iterator2.f();\n          return _context2.finish(19);\n        case 22:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _marked2, null, [[2, 16, 19, 22]]);\n  }\n  var contours = function contours(data) {\n    return _toConsumableArray(tricontours(data));\n  };\n\n  // API\n  contours.x = function (_) {\n    return _ ? (x = _, contours) : x;\n  };\n  contours.y = function (_) {\n    return _ ? (y = _, contours) : y;\n  };\n  contours.value = function (_) {\n    return _ ? (value = _, contours) : value;\n  };\n  contours.thresholds = function (_) {\n    return _ ? (thresholds = _, contours) : thresholds;\n  };\n  contours.triangulate = function (_) {\n    return _ ? (triangulate = _, contours) : triangulate;\n  };\n  contours.pointInterpolate = function (_) {\n    return _ ? (pointInterpolate = _, contours) : pointInterpolate;\n  };\n  contours.ringsort = function (_) {\n    return _ ? (ringsort = _, contours) : ringsort;\n  };\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands;\n\n  // expose the internals (useful for debugging, not part of the API)\n  contours._values = function () {\n    return values;\n  };\n  contours._triangulation = function () {\n    return triangulation;\n  };\n  return contours;\n\n  // navigate a triangle\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n  function tricontour(triangulation, values) {\n    var v0 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    // sanity check\n    var _iterator3 = _createForOfIteratorHelper(values),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var d = _step3.value;\n        if (!isFinite(d)) throw [\"Invalid value\", d];\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    var halfedges = triangulation.halfedges,\n      hull = triangulation.hull,\n      inedges = triangulation.inedges,\n      triangles = triangulation.triangles,\n      n = values.length;\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n    function alpha(i, j) {\n      var u = values[i],\n        v = values[j];\n      if (u <= v0 && v >= v0 && u < v) {\n        return (v0 - u) / (v - u);\n      }\n    }\n\n    // create the path from the first exit; cancel visited halfedges\n    var rings = [],\n      visited = new Uint8Array(halfedges.length).fill(0);\n    var path, i, j, k, a;\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n      i = k;\n      path = [];\n      while ((a = edgealpha(i)) > 0) {\n        var _ref = [triangles[i], triangles[j = next(i)]],\n          ti = _ref[0],\n          tj = _ref[1];\n\n        // is our tour done?\n        if (path.length && ti === path[0].ti && tj === path[0].tj || path.length > 2 * n) break;\n        visited[i] = 1;\n        path.push({\n          ti: ti,\n          tj: tj,\n          a: a\n        });\n\n        // jump into the adjacent triangle\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          }\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          }\n          // debugger;\n        }\n\n        // or follow the hull\n        else {\n          var h = (hull.indexOf(triangles[i]) + 1) % hull.length;\n          while (values[hull[h]] < v0) {\n            // debugger;\n            h = (h + 1) % hull.length;\n          }\n          while (values[hull[h]] >= v0) {\n            path.push({\n              ti: hull[h],\n              tj: hull[h],\n              a: 0\n            });\n            h = (h + 1) % hull.length;\n          }\n\n          // take that entry\n          j = inedges[hull[h]];\n          path.push({\n            ti: hull[h],\n            tj: triangles[j],\n            a: alpha(hull[h], triangles[j])\n          });\n          if (edgealpha(i = next(j)) > 0) continue;\n          if (edgealpha(i = prev(j)) > 0) continue;\n        }\n      }\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(function (_ref2) {\n          var ti = _ref2.ti,\n            tj = _ref2.tj,\n            a = _ref2.a;\n          return pointInterpolate(ti, tj, a);\n        }));\n      }\n    }\n\n    // special case all values on the hull are >=v0, add the hull\n    if (hull.every(function (d) {\n      return values[d] >= v0;\n    })) {\n      rings.unshift(Array.from(hull).concat([hull[0]]).map(function (i) {\n        return pointInterpolate(i, i, 0);\n      }));\n    }\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}