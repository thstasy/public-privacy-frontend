{"ast":null,"code":"import _regeneratorRuntime from \"/Users/stasy/Desktop/Public+Privacy_0831/public-privacy-frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/stasy/Desktop/Public+Privacy_0831/public-privacy-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/stasy/Desktop/Public+Privacy_0831/public-privacy-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/stasy/Desktop/Public+Privacy_0831/public-privacy-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/stasy/Desktop/Public+Privacy_0831/public-privacy-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport Path from \"./path.js\";\nimport Polygon from \"./polygon.js\";\nvar Voronoi = /*#__PURE__*/function () {\n  function Voronoi(delaunay) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 960, 500],\n      _ref2 = _slicedToArray(_ref, 4),\n      xmin = _ref2[0],\n      ymin = _ref2[1],\n      xmax = _ref2[2],\n      ymax = _ref2[3];\n    _classCallCheck(this, Voronoi);\n    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error(\"invalid bounds\");\n    this.delaunay = delaunay;\n    this._circumcenters = new Float64Array(delaunay.points.length * 2);\n    this.vectors = new Float64Array(delaunay.points.length * 2);\n    this.xmax = xmax, this.xmin = xmin;\n    this.ymax = ymax, this.ymin = ymin;\n    this._init();\n  }\n  _createClass(Voronoi, [{\n    key: \"update\",\n    value: function update() {\n      this.delaunay.update();\n      this._init();\n      return this;\n    }\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var _this$delaunay = this.delaunay,\n        points = _this$delaunay.points,\n        hull = _this$delaunay.hull,\n        triangles = _this$delaunay.triangles,\n        vectors = this.vectors;\n      var bx, by; // lazily computed barycenter of the hull\n\n      // Compute circumcenters.\n      var circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);\n      for (var i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {\n        var t1 = triangles[i] * 2;\n        var t2 = triangles[i + 1] * 2;\n        var t3 = triangles[i + 2] * 2;\n        var _x = points[t1];\n        var _y = points[t1 + 1];\n        var x2 = points[t2];\n        var y2 = points[t2 + 1];\n        var x3 = points[t3];\n        var y3 = points[t3 + 1];\n        var dx = x2 - _x;\n        var dy = y2 - _y;\n        var ex = x3 - _x;\n        var ey = y3 - _y;\n        var ab = (dx * ey - dy * ex) * 2;\n        if (Math.abs(ab) < 1e-9) {\n          // For a degenerate triangle, the circumcenter is at the infinity, in a\n          // direction orthogonal to the halfedge and away from the “center” of\n          // the diagram <bx, by>, defined as the hull’s barycenter.\n          if (bx === undefined) {\n            bx = by = 0;\n            var _iterator = _createForOfIteratorHelper(hull),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var _i = _step.value;\n                bx += points[_i * 2], by += points[_i * 2 + 1];\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n            bx /= hull.length, by /= hull.length;\n          }\n          var a = 1e9 * Math.sign((bx - _x) * ey - (by - _y) * ex);\n          x = (_x + x3) / 2 - a * ey;\n          y = (_y + y3) / 2 + a * ex;\n        } else {\n          var d = 1 / ab;\n          var bl = dx * dx + dy * dy;\n          var cl = ex * ex + ey * ey;\n          x = _x + (ey * bl - dy * cl) * d;\n          y = _y + (dx * cl - ex * bl) * d;\n        }\n        circumcenters[j] = x;\n        circumcenters[j + 1] = y;\n      }\n\n      // Compute exterior cell rays.\n      var h = hull[hull.length - 1];\n      var p0,\n        p1 = h * 4;\n      var x0,\n        x1 = points[2 * h];\n      var y0,\n        y1 = points[2 * h + 1];\n      vectors.fill(0);\n      for (var _i2 = 0; _i2 < hull.length; ++_i2) {\n        h = hull[_i2];\n        p0 = p1, x0 = x1, y0 = y1;\n        p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];\n        vectors[p0 + 2] = vectors[p1] = y0 - y1;\n        vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      var buffer = context == null ? context = new Path() : undefined;\n      var _this$delaunay2 = this.delaunay,\n        halfedges = _this$delaunay2.halfedges,\n        inedges = _this$delaunay2.inedges,\n        hull = _this$delaunay2.hull,\n        circumcenters = this.circumcenters,\n        vectors = this.vectors;\n      if (hull.length <= 1) return null;\n      for (var i = 0, n = halfedges.length; i < n; ++i) {\n        var j = halfedges[i];\n        if (j < i) continue;\n        var ti = Math.floor(i / 3) * 2;\n        var tj = Math.floor(j / 3) * 2;\n        var xi = circumcenters[ti];\n        var yi = circumcenters[ti + 1];\n        var xj = circumcenters[tj];\n        var yj = circumcenters[tj + 1];\n        this._renderSegment(xi, yi, xj, yj, context);\n      }\n      var h0,\n        h1 = hull[hull.length - 1];\n      for (var _i3 = 0; _i3 < hull.length; ++_i3) {\n        h0 = h1, h1 = hull[_i3];\n        var t = Math.floor(inedges[h1] / 3) * 2;\n        var x = circumcenters[t];\n        var y = circumcenters[t + 1];\n        var v = h0 * 4;\n        var p = this._project(x, y, vectors[v + 2], vectors[v + 3]);\n        if (p) this._renderSegment(x, y, p[0], p[1], context);\n      }\n      return buffer && buffer.value();\n    }\n  }, {\n    key: \"renderBounds\",\n    value: function renderBounds(context) {\n      var buffer = context == null ? context = new Path() : undefined;\n      context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);\n      return buffer && buffer.value();\n    }\n  }, {\n    key: \"renderCell\",\n    value: function renderCell(i, context) {\n      var buffer = context == null ? context = new Path() : undefined;\n      var points = this._clip(i);\n      if (points === null || !points.length) return;\n      context.moveTo(points[0], points[1]);\n      var n = points.length;\n      while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1) n -= 2;\n      for (var _i4 = 2; _i4 < n; _i4 += 2) {\n        if (points[_i4] !== points[_i4 - 2] || points[_i4 + 1] !== points[_i4 - 1]) context.lineTo(points[_i4], points[_i4 + 1]);\n      }\n      context.closePath();\n      return buffer && buffer.value();\n    }\n  }, {\n    key: \"cellPolygons\",\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function cellPolygons() {\n      var points, i, n, cell;\n      return _regeneratorRuntime().wrap(function cellPolygons$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            points = this.delaunay.points;\n            i = 0, n = points.length / 2;\n          case 2:\n            if (!(i < n)) {\n              _context.next = 11;\n              break;\n            }\n            cell = this.cellPolygon(i);\n            if (!cell) {\n              _context.next = 8;\n              break;\n            }\n            cell.index = i;\n            _context.next = 8;\n            return cell;\n          case 8:\n            ++i;\n            _context.next = 2;\n            break;\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }, cellPolygons, this);\n    })\n  }, {\n    key: \"cellPolygon\",\n    value: function cellPolygon(i) {\n      var polygon = new Polygon();\n      this.renderCell(i, polygon);\n      return polygon.value();\n    }\n  }, {\n    key: \"_renderSegment\",\n    value: function _renderSegment(x0, y0, x1, y1, context) {\n      var S;\n      var c0 = this._regioncode(x0, y0);\n      var c1 = this._regioncode(x1, y1);\n      if (c0 === 0 && c1 === 0) {\n        context.moveTo(x0, y0);\n        context.lineTo(x1, y1);\n      } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {\n        context.moveTo(S[0], S[1]);\n        context.lineTo(S[2], S[3]);\n      }\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(i, x, y) {\n      if ((x = +x, x !== x) || (y = +y, y !== y)) return false;\n      return this.delaunay._step(i, x, y) === i;\n    }\n  }, {\n    key: \"neighbors\",\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function neighbors(i) {\n      var ci, _iterator2, _step2, j, cj, ai, li, aj, lj;\n      return _regeneratorRuntime().wrap(function neighbors$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            ci = this._clip(i);\n            if (!ci) {\n              _context2.next = 33;\n              break;\n            }\n            _iterator2 = _createForOfIteratorHelper(this.delaunay.neighbors(i));\n            _context2.prev = 3;\n            _iterator2.s();\n          case 5:\n            if ((_step2 = _iterator2.n()).done) {\n              _context2.next = 25;\n              break;\n            }\n            j = _step2.value;\n            cj = this._clip(j); // find the common edge\n            if (!cj) {\n              _context2.next = 23;\n              break;\n            }\n            ai = 0, li = ci.length;\n          case 10:\n            if (!(ai < li)) {\n              _context2.next = 23;\n              break;\n            }\n            aj = 0, lj = cj.length;\n          case 12:\n            if (!(aj < lj)) {\n              _context2.next = 20;\n              break;\n            }\n            if (!(ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj])) {\n              _context2.next = 17;\n              break;\n            }\n            _context2.next = 16;\n            return j;\n          case 16:\n            return _context2.abrupt(\"break\", 23);\n          case 17:\n            aj += 2;\n            _context2.next = 12;\n            break;\n          case 20:\n            ai += 2;\n            _context2.next = 10;\n            break;\n          case 23:\n            _context2.next = 5;\n            break;\n          case 25:\n            _context2.next = 30;\n            break;\n          case 27:\n            _context2.prev = 27;\n            _context2.t0 = _context2[\"catch\"](3);\n            _iterator2.e(_context2.t0);\n          case 30:\n            _context2.prev = 30;\n            _iterator2.f();\n            return _context2.finish(30);\n          case 33:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, neighbors, this, [[3, 27, 30, 33]]);\n    })\n  }, {\n    key: \"_cell\",\n    value: function _cell(i) {\n      var circumcenters = this.circumcenters,\n        _this$delaunay3 = this.delaunay,\n        inedges = _this$delaunay3.inedges,\n        halfedges = _this$delaunay3.halfedges,\n        triangles = _this$delaunay3.triangles;\n      var e0 = inedges[i];\n      if (e0 === -1) return null; // coincident point\n      var points = [];\n      var e = e0;\n      do {\n        var t = Math.floor(e / 3);\n        points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);\n        e = e % 3 === 2 ? e - 2 : e + 1;\n        if (triangles[e] !== i) break; // bad triangulation\n        e = halfedges[e];\n      } while (e !== e0 && e !== -1);\n      return points;\n    }\n  }, {\n    key: \"_clip\",\n    value: function _clip(i) {\n      // degenerate case (1 valid point: return the box)\n      if (i === 0 && this.delaunay.hull.length === 1) {\n        return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n      }\n      var points = this._cell(i);\n      if (points === null) return null;\n      var V = this.vectors;\n      var v = i * 4;\n      return this._simplify(V[v] || V[v + 1] ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3]) : this._clipFinite(i, points));\n    }\n  }, {\n    key: \"_clipFinite\",\n    value: function _clipFinite(i, points) {\n      var n = points.length;\n      var P = null;\n      var x0,\n        y0,\n        x1 = points[n - 2],\n        y1 = points[n - 1];\n      var c0,\n        c1 = this._regioncode(x1, y1);\n      var e0,\n        e1 = 0;\n      for (var j = 0; j < n; j += 2) {\n        x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];\n        c0 = c1, c1 = this._regioncode(x1, y1);\n        if (c0 === 0 && c1 === 0) {\n          e0 = e1, e1 = 0;\n          if (P) P.push(x1, y1);else P = [x1, y1];\n        } else {\n          var S = void 0,\n            sx0 = void 0,\n            sy0 = void 0,\n            sx1 = void 0,\n            sy1 = void 0;\n          if (c0 === 0) {\n            if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;\n            var _S = S;\n            var _S2 = _slicedToArray(_S, 4);\n            sx0 = _S2[0];\n            sy0 = _S2[1];\n            sx1 = _S2[2];\n            sy1 = _S2[3];\n          } else {\n            if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;\n            var _S3 = S;\n            var _S4 = _slicedToArray(_S3, 4);\n            sx1 = _S4[0];\n            sy1 = _S4[1];\n            sx0 = _S4[2];\n            sy0 = _S4[3];\n            e0 = e1, e1 = this._edgecode(sx0, sy0);\n            if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n            if (P) P.push(sx0, sy0);else P = [sx0, sy0];\n          }\n          e0 = e1, e1 = this._edgecode(sx1, sy1);\n          if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n          if (P) P.push(sx1, sy1);else P = [sx1, sy1];\n        }\n      }\n      if (P) {\n        e0 = e1, e1 = this._edgecode(P[0], P[1]);\n        if (e0 && e1) this._edge(i, e0, e1, P, P.length);\n      } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n        return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];\n      }\n      return P;\n    }\n  }, {\n    key: \"_clipSegment\",\n    value: function _clipSegment(x0, y0, x1, y1, c0, c1) {\n      // for more robustness, always consider the segment in the same order\n      var flip = c0 < c1;\n      if (flip) {\n        var _ref3 = [x1, y1, x0, y0, c1, c0];\n        x0 = _ref3[0];\n        y0 = _ref3[1];\n        x1 = _ref3[2];\n        y1 = _ref3[3];\n        c0 = _ref3[4];\n        c1 = _ref3[5];\n      }\n      while (true) {\n        if (c0 === 0 && c1 === 0) return flip ? [x1, y1, x0, y0] : [x0, y0, x1, y1];\n        if (c0 & c1) return null;\n        var x = void 0,\n          y = void 0,\n          c = c0 || c1;\n        if (c & 8) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;else if (c & 4) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;else if (c & 2) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;\n        if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);\n      }\n    }\n  }, {\n    key: \"_clipInfinite\",\n    value: function _clipInfinite(i, points, vx0, vy0, vxn, vyn) {\n      var P = Array.from(points),\n        p;\n      if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);\n      if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);\n      if (P = this._clipFinite(i, P)) {\n        for (var j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {\n          c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);\n          if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;\n        }\n      } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {\n        P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];\n      }\n      return P;\n    }\n  }, {\n    key: \"_edge\",\n    value: function _edge(i, e0, e1, P, j) {\n      while (e0 !== e1) {\n        var x = void 0,\n          y = void 0;\n        switch (e0) {\n          case 5:\n            e0 = 4;\n            continue;\n          // top-left\n          case 4:\n            e0 = 6, x = this.xmax, y = this.ymin;\n            break;\n          // top\n          case 6:\n            e0 = 2;\n            continue;\n          // top-right\n          case 2:\n            e0 = 10, x = this.xmax, y = this.ymax;\n            break;\n          // right\n          case 10:\n            e0 = 8;\n            continue;\n          // bottom-right\n          case 8:\n            e0 = 9, x = this.xmin, y = this.ymax;\n            break;\n          // bottom\n          case 9:\n            e0 = 1;\n            continue;\n          // bottom-left\n          case 1:\n            e0 = 5, x = this.xmin, y = this.ymin;\n            break;\n          // left\n        }\n        // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are\n        // undefined, the conditional statement will be executed.\n        if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {\n          P.splice(j, 0, x, y), j += 2;\n        }\n      }\n      return j;\n    }\n  }, {\n    key: \"_project\",\n    value: function _project(x0, y0, vx, vy) {\n      var t = Infinity,\n        c,\n        x,\n        y;\n      if (vy < 0) {\n        // top\n        if (y0 <= this.ymin) return null;\n        if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;\n      } else if (vy > 0) {\n        // bottom\n        if (y0 >= this.ymax) return null;\n        if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;\n      }\n      if (vx > 0) {\n        // right\n        if (x0 >= this.xmax) return null;\n        if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;\n      } else if (vx < 0) {\n        // left\n        if (x0 <= this.xmin) return null;\n        if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;\n      }\n      return [x, y];\n    }\n  }, {\n    key: \"_edgecode\",\n    value: function _edgecode(x, y) {\n      return (x === this.xmin ? 1 : x === this.xmax ? 2 : 0) | (y === this.ymin ? 4 : y === this.ymax ? 8 : 0);\n    }\n  }, {\n    key: \"_regioncode\",\n    value: function _regioncode(x, y) {\n      return (x < this.xmin ? 1 : x > this.xmax ? 2 : 0) | (y < this.ymin ? 4 : y > this.ymax ? 8 : 0);\n    }\n  }, {\n    key: \"_simplify\",\n    value: function _simplify(P) {\n      if (P && P.length > 4) {\n        for (var i = 0; i < P.length; i += 2) {\n          var j = (i + 2) % P.length,\n            k = (i + 4) % P.length;\n          if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {\n            P.splice(j, 2), i -= 2;\n          }\n        }\n        if (!P.length) P = null;\n      }\n      return P;\n    }\n  }]);\n  return Voronoi;\n}();\nexport { Voronoi as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}