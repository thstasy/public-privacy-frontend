{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/stasy/Desktop/Public+Privacy_0831/public-privacy-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Delaunay } from \"d3-delaunay\";\nimport { geoRotation, geoStereographic } from \"d3-geo\";\nimport { extent } from \"d3-array\";\nimport { asin, atan2, cos, degrees, max, min, radians, sign, sin, sqrt } from \"./math.js\";\nimport { cartesianNormalize as normalize, cartesianCross as cross, cartesianDot as dot, cartesianAdd } from \"./cartesian.js\";\n\n// Converts 3D Cartesian to spherical coordinates (degrees).\nfunction spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]) * degrees, asin(max(-1, min(1, cartesian[2]))) * degrees];\n}\n\n// Converts spherical coordinates (degrees) to 3D Cartesian.\nfunction cartesian(coordinates) {\n  var lambda = coordinates[0] * radians,\n    phi = coordinates[1] * radians,\n    cosphi = cos(phi);\n  return [cosphi * cos(lambda), cosphi * sin(lambda), sin(phi)];\n}\n\n// Spherical excess of a triangle (in spherical coordinates)\nexport function excess(triangle) {\n  triangle = triangle.map(function (p) {\n    return cartesian(p);\n  });\n  return dot(triangle[0], cross(triangle[2], triangle[1]));\n}\nexport function geoDelaunay(points) {\n  var delaunay = geo_delaunay_from(points),\n    triangles = geo_triangles(delaunay),\n    edges = geo_edges(triangles, points),\n    neighbors = geo_neighbors(triangles, points.length),\n    find = geo_find(neighbors, points),\n    circumcenters = geo_circumcenters(triangles, points),\n    _geo_polygons = geo_polygons(circumcenters, triangles, points),\n    polygons = _geo_polygons.polygons,\n    centers = _geo_polygons.centers,\n    mesh = geo_mesh(polygons),\n    hull = geo_hull(triangles, points),\n    urquhart = geo_urquhart(edges, triangles);\n  return {\n    delaunay: delaunay,\n    edges: edges,\n    triangles: triangles,\n    centers: centers,\n    neighbors: neighbors,\n    polygons: polygons,\n    mesh: mesh,\n    hull: hull,\n    urquhart: urquhart,\n    find: find\n  };\n}\nfunction geo_find(neighbors, points) {\n  function distance2(a, b) {\n    var x = a[0] - b[0],\n      y = a[1] - b[1],\n      z = a[2] - b[2];\n    return x * x + y * y + z * z;\n  }\n  return function find(x, y, next) {\n    if (next === undefined) next = 0;\n    var cell,\n      dist,\n      found = next;\n    var xyz = cartesian([x, y]);\n    do {\n      cell = next;\n      next = null;\n      dist = distance2(xyz, cartesian(points[cell]));\n      neighbors[cell].forEach(function (i) {\n        var ndist = distance2(xyz, cartesian(points[i]));\n        if (ndist < dist) {\n          dist = ndist;\n          next = i;\n          found = i;\n          return;\n        }\n      });\n    } while (next !== null);\n    return found;\n  };\n}\nfunction geo_delaunay_from(points) {\n  if (points.length < 2) return {};\n\n  // find a valid point to send to infinity\n  var pivot = 0;\n  while (isNaN(points[pivot][0] + points[pivot][1]) && pivot++ < points.length);\n  var r = geoRotation(points[pivot]),\n    projection = geoStereographic().translate([0, 0]).scale(1).rotate(r.invert([180, 0]));\n  points = points.map(projection);\n  var zeros = [];\n  var max2 = 1;\n  for (var i = 0, n = points.length; i < n; i++) {\n    var m = Math.pow(points[i][0], 2) + Math.pow(points[i][1], 2);\n    if (!isFinite(m) || m > 1e32) zeros.push(i);else if (m > max2) max2 = m;\n  }\n  var FAR = 1e6 * sqrt(max2);\n  zeros.forEach(function (i) {\n    return points[i] = [FAR, 0];\n  });\n\n  // Add infinite horizon points\n  points.push([0, FAR]);\n  points.push([-FAR, 0]);\n  points.push([0, -FAR]);\n  var delaunay = Delaunay.from(points);\n  delaunay.projection = projection;\n\n  // clean up the triangulation\n  var triangles = delaunay.triangles,\n    halfedges = delaunay.halfedges,\n    inedges = delaunay.inedges;\n  var degenerate = [];\n  for (var _i = 0, l = halfedges.length; _i < l; _i++) {\n    if (halfedges[_i] < 0) {\n      var j = _i % 3 == 2 ? _i - 2 : _i + 1;\n      var k = _i % 3 == 0 ? _i + 2 : _i - 1;\n      var a = halfedges[j];\n      var b = halfedges[k];\n      halfedges[a] = b;\n      halfedges[b] = a;\n      halfedges[j] = halfedges[k] = -1;\n      triangles[_i] = triangles[j] = triangles[k] = pivot;\n      inedges[triangles[a]] = a % 3 == 0 ? a + 2 : a - 1;\n      inedges[triangles[b]] = b % 3 == 0 ? b + 2 : b - 1;\n      degenerate.push(Math.min(_i, j, k));\n      _i += 2 - _i % 3;\n    } else if (triangles[_i] > points.length - 3 - 1) {\n      triangles[_i] = pivot;\n    }\n  }\n\n  // there should always be 4 degenerate triangles\n  // console.warn(degenerate);\n  return delaunay;\n}\nfunction geo_edges(triangles, points) {\n  var _index = new Set();\n  if (points.length === 2) return [[0, 1]];\n  triangles.forEach(function (tri) {\n    if (tri[0] === tri[1]) return;\n    if (excess(tri.map(function (i) {\n      return points[i];\n    })) < 0) return;\n    for (var i = 0, j; i < 3; i++) {\n      j = (i + 1) % 3;\n      _index.add(extent([tri[i], tri[j]]).join(\"-\"));\n    }\n  });\n  return Array.from(_index, function (d) {\n    return d.split(\"-\").map(Number);\n  });\n}\nfunction geo_triangles(delaunay) {\n  var triangles = delaunay.triangles;\n  if (!triangles) return [];\n  var geo_triangles = [];\n  for (var i = 0, n = triangles.length / 3; i < n; i++) {\n    var a = triangles[3 * i],\n      b = triangles[3 * i + 1],\n      c = triangles[3 * i + 2];\n    if (a !== b && b !== c) {\n      geo_triangles.push([a, c, b]);\n    }\n  }\n  return geo_triangles;\n}\nfunction geo_circumcenters(triangles, points) {\n  // if (!use_centroids) {\n  return triangles.map(function (tri) {\n    var c = tri.map(function (i) {\n        return points[i];\n      }).map(cartesian),\n      V = cartesianAdd(cartesianAdd(cross(c[1], c[0]), cross(c[2], c[1])), cross(c[0], c[2]));\n    return spherical(normalize(V));\n  });\n  /*} else {\n    return triangles.map(tri => {\n      return d3.geoCentroid({\n        type: \"MultiPoint\",\n        coordinates: tri.map(i => points[i])\n      });\n    });\n  }*/\n}\n\nfunction geo_neighbors(triangles, npoints) {\n  var neighbors = [];\n  triangles.forEach(function (tri) {\n    for (var j = 0; j < 3; j++) {\n      var a = tri[j],\n        b = tri[(j + 1) % 3];\n      neighbors[a] = neighbors[a] || [];\n      neighbors[a].push(b);\n    }\n  });\n\n  // degenerate cases\n  if (triangles.length === 0) {\n    if (npoints === 2) neighbors[0] = [1], neighbors[1] = [0];else if (npoints === 1) neighbors[0] = [];\n  }\n  return neighbors;\n}\nfunction geo_polygons(circumcenters, triangles, points) {\n  var polygons = [];\n  var centers = circumcenters.slice();\n  if (triangles.length === 0) {\n    if (points.length < 2) return {\n      polygons: polygons,\n      centers: centers\n    };\n    if (points.length === 2) {\n      // two hemispheres\n      var a = cartesian(points[0]),\n        b = cartesian(points[1]),\n        m = normalize(cartesianAdd(a, b)),\n        d = normalize(cross(a, b)),\n        c = cross(m, d);\n      var poly = [m, cross(m, c), cross(cross(m, c), c), cross(cross(cross(m, c), c), c)].map(spherical).map(supplement);\n      return polygons.push(poly), polygons.push(poly.slice().reverse()), {\n        polygons: polygons,\n        centers: centers\n      };\n    }\n  }\n  triangles.forEach(function (tri, t) {\n    for (var j = 0; j < 3; j++) {\n      var _a = tri[j],\n        _b = tri[(j + 1) % 3],\n        _c = tri[(j + 2) % 3];\n      polygons[_a] = polygons[_a] || [];\n      polygons[_a].push([_b, _c, t, [_a, _b, _c]]);\n    }\n  });\n\n  // reorder each polygon\n  var reordered = polygons.map(function (poly) {\n    var p = [poly[0][2]]; // t\n    var k = poly[0][1]; // k = c\n    for (var i = 1; i < poly.length; i++) {\n      // look for b = k\n      for (var j = 0; j < poly.length; j++) {\n        if (poly[j][0] == k) {\n          k = poly[j][1];\n          p.push(poly[j][2]);\n          break;\n        }\n      }\n    }\n    if (p.length > 2) {\n      return p;\n    } else if (p.length == 2) {\n      var R0 = o_midpoint(points[poly[0][3][0]], points[poly[0][3][1]], centers[p[0]]),\n        R1 = o_midpoint(points[poly[0][3][2]], points[poly[0][3][0]], centers[p[0]]);\n      var i0 = supplement(R0),\n        i1 = supplement(R1);\n      return [p[0], i1, p[1], i0];\n    }\n  });\n  function supplement(point) {\n    var f = -1;\n    centers.slice(triangles.length, Infinity).forEach(function (p, i) {\n      if (p[0] === point[0] && p[1] === point[1]) f = i + triangles.length;\n    });\n    if (f < 0) f = centers.length, centers.push(point);\n    return f;\n  }\n  return {\n    polygons: reordered,\n    centers: centers\n  };\n}\nfunction o_midpoint(a, b, c) {\n  a = cartesian(a);\n  b = cartesian(b);\n  c = cartesian(c);\n  var s = sign(dot(cross(b, a), c));\n  return spherical(normalize(cartesianAdd(a, b)).map(function (d) {\n    return s * d;\n  }));\n}\nfunction geo_mesh(polygons) {\n  var mesh = [];\n  polygons.forEach(function (poly) {\n    if (!poly) return;\n    var p = poly[poly.length - 1];\n    var _iterator = _createForOfIteratorHelper(poly),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var q = _step.value;\n        if (q > p) mesh.push([p, q]);\n        p = q;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  });\n  return mesh;\n}\nfunction geo_urquhart(edges, triangles) {\n  return function (distances) {\n    var _lengths = new Map(),\n      _urquhart = new Map();\n    edges.forEach(function (edge, i) {\n      var u = edge.join(\"-\");\n      _lengths.set(u, distances[i]);\n      _urquhart.set(u, true);\n    });\n    triangles.forEach(function (tri) {\n      var l = 0,\n        remove = -1;\n      for (var j = 0; j < 3; j++) {\n        var u = extent([tri[j], tri[(j + 1) % 3]]).join(\"-\");\n        if (_lengths.get(u) > l) {\n          l = _lengths.get(u);\n          remove = u;\n        }\n      }\n      _urquhart.set(remove, false);\n    });\n    return edges.map(function (edge) {\n      return _urquhart.get(edge.join(\"-\"));\n    });\n  };\n}\nfunction geo_hull(triangles, points) {\n  var _hull = new Set(),\n    hull = [];\n  triangles.map(function (tri) {\n    if (excess(tri.map(function (i) {\n      return points[i > points.length ? 0 : i];\n    })) > 1e-12) return;\n    for (var i = 0; i < 3; i++) {\n      var e = [tri[i], tri[(i + 1) % 3]],\n        code = \"\".concat(e[0], \"-\").concat(e[1]);\n      if (_hull.has(code)) _hull.delete(code);else _hull.add(\"\".concat(e[1], \"-\").concat(e[0]));\n    }\n  });\n  var _index = new Map();\n  var start;\n  _hull.forEach(function (e) {\n    e = e.split(\"-\").map(Number);\n    _index.set(e[0], e[1]);\n    start = e[0];\n  });\n  if (start === undefined) return hull;\n  var next = start;\n  do {\n    hull.push(next);\n    var n = _index.get(next);\n    _index.set(next, -1);\n    next = n;\n  } while (next > -1 && next !== start);\n  return hull;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}